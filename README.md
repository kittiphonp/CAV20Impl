# Contents
This repository contains all tools and their sources relevant in the CAV'20 paper

  "Widest Paths and Global Propagation in Bounded Value Iteration for Stochastic Games",

namely:

1. The original implementation of the BVI algorithm in [Kelmendi+, CAV'18] (mycode/DFL)
2. A modification of 1 (mycode/DFL_m)
3. An implementation of our BVI algorithms as an extension of 1) (mycode/WP)

Implementation 1 is provided by the authors of [Kelmendi+, CAV'18], which is made by 
modifying the source code of PRISM-GAMES (https://www.prismmodelchecker.org/games/).

Our CAV'20 paper is available at [Springer](https://doi.org/10.1007/978-3-030-53291-8_19) and [arXiv](https://arxiv.org/abs/2007.07421).


# How to reproduce the experimental result
The following procedure is checked on Debian 9 with 
openJDK 11.0.8 and python 3.5.3.

1. Download the repository and put it to any directory
2. Open `$yourRoot/scripts/env.sh` and change the description of myRoot to the root of the repository
3. Open terminal, do `cd $yourRoot/scripts` and `./make.sh` to compile the codes
4. Run `./generate_mytable1.sh` to reproduce the experimental result


# Files
- `README.md`    ... this file
- `mymodels`     ... the benchmark set called by the main code
- `mycode`       ... main code that implements the BVI algorithms (DFL, DFL_m, DFL-BRTDP, and WP)
- `scripts`      ... scripts that conduct experiments
- `etc`          ... some resources used to compile the codes (already applied to the codes)

When you run the script `generate_mytable1.sh`, the following files will be created:

- `mytable1.txt` ... a reproduction of table1 in our paper
- `mydata`       ... log file


# The code
Each of the directory `mycode/$ALGO_NAME` is a modification of the source file of PRISM-games 2.0 (https://www.prismmodelchecker.org/games/download.php).

The java source code of each implementation can be found in `mycode/$ALGO_NAME/src`. 
Our BVI technique via Widest Path Problem appears in `mycode/WP/src/explicit/STPGModelChecker.java`, 
see the method 'computeReachProbsValIterBounded' (Line 2107-2419).

The code in `mycode/genGraph` is used to compute the number of End Components (ECs); see also `countEC.py` below.


# The scripts (and an auxiliary code)
In the folder `scripts` there are the following shell-scripts and a python code.

- `env.sh`                ... it contains the root directory information used in other scripts.
- `make.sh`               ... it runs `make` for each implementation.
- `run_benchmarks.sh`     ... it runs the tests on the models and generates log files. The following should be noted.
  -    For the sake of fast computation, the time limit for each BVI computation is set to 1 minute 
       (Line 171). This is much smaller than the number in our paper (6 hours). For more accurate 
       reproduction of table 1, change this number and take a longer time limit.
  -    The computation time reported in our CAV'20 paper is the time for BVI computation which does not include 
       the time for model construction and some shared pre- and post-computation. 
       Because of this, you may see a timeout even if your time budget is longer than the reported time in our CAV'20 paper.
       This can be resolved by taking a longer time limit.
  -    In Line 39, the number of repetitions for BRTDP is defined (it is a randomized algorithm). 
       We set the number to 2 for the sake of fast computation, while we did 5 repetitions in our paper.
- `read_logs.sh`         ... it reads the generated log files and reproduces table1 in our paper. 
- `generate_mytable1.sh` ... it calls the other 2 scripts.
- `countEC.py`           ... it computes the number of ECs in each model. It calls for the graph data of the model
                              which can be generated by the code in `mycode/genGraph`. Although PRISM can also compute
                              this value by `-exportmecs` option, we suffer an Out Of Memory error for some instances.


# The log files
The log directory `mydata` is created when you execute the script `generate_mytable1.sh`.
For each model and algorithm, the following log files are created:

- .log file  ... the log produced by the main code
- .stat file ... the log taken by the OS (the "/usr/bin/time" function)

In `mydata/EC` the following files are also created:

- .model file .. the graph data of the model which is used by `countEC.py`
- .txt file  ... the output of `countEC.py`

# Usage #
One can conduct tests for specific models and algorithms as follows.
Also you can find some options by executing `$yourRoot/mycode/WP/bin/prism -help`

## DFL 
To use the implementation of BVI by [Kelmendi+, CAV'18], first
`cd $yourRoot/mycode/DFL`.
Then execute `bin/prism ../../mymodels/$CHOOSEMODELFILE ../../mymodels/$CHOOSEPROPERTYFILE -BVI_A`,
e.g. `bin/prism ../../mymodels/mdsm/mdsm.prism ../../mymodels/mdsm/mdsm.props -BVI_A`.

## DFL_m 
To use the modification of DFL, first
`cd $yourRoot/mycode/DFL_m`.
Then execute `bin/prism ../../mymodels/$CHOOSEMODELFILE ../../mymodels/$CHOOSEPROPERTYFILE -BVI_A`,
e.g. `bin/prism ../../mymodels/mdsm/mdsm.prism ../../mymodels/mdsm/mdsm.props -BVI_A`.

## DFL_BRTDP 
To use the implementation of BRTDP by [Kelmendi+, CAV'18], first
`cd $yourRoot/mycode/DFL`.
Then execute `bin/prism ../../mymodels/$CHOOSEMODELFILE ../../mymodels/$CHOOSEPROPERTYFILE -heuristics RTDP_ADJ`,
e.g. `bin/prism ../../mymodels/mdsm/mdsm.prism ../../mymodels/mdsm/mdsm.props -heuristics RTDP_ADJ`.

## WP
To use the implementation of our WP algorithm, first 
`cd $yourRoot/mycode/WP/`.
Then execute `bin/prism ../../mymodels/$CHOOSEMODELFILE ../../mymodels/$CHOOSEPROPERTYFILE -BVI_A`,
e.g. `bin/prism ../../mymodels/mdsm/mdsm.prism ../../mymodels/mdsm/mdsm.props -BVI_A`.

## genGraph
To generate the graph data of the model for `countEC.py`, first 
`cd $yourRoot/mycode/WP/`.
Then execute `bin/prism ../../mymodels/$CHOOSEMODELFILE ../../mymodels/$CHOOSEPROPERTYFILE -BVI_A`,
e.g. `bin/prism ../../mymodels/mdsm/mdsm.prism ../../mymodels/mdsm/mdsm.props -BVI_A`.

This will generate `model.txt` in the current directory.


# References 
[Kelmendi+, CAV'18] Kelmendi, E., Kramer, J., Kretinsky, J., Weininger, M.: Value Iteration for Simple Stochastic Games: Stopping Criterion and Learning Algorithm, Proc. CAV 2018, pp. 623-642. Springer (2018)

